---
title: '프론트엔드 개발자를 위한 디자인 패턴 실전 가이드'
date: '2025-11-15'
description: '면접용 이론이 아닌, React 실무에서 마주치는 디자인 패턴 사례와 적용 노하우'
tags: ['개발', 'CS']
thumbnail: '/images/2025/1/BlogThumbnail.png'
---

최근 `면접을 위한 CS 전공 지식 노트`를 읽으면서 디자인 패턴을 다시 정리하게 되었다. 사실 예전에는 "디자인 패턴? 백엔드에서나 쓰는 거 아냐?"라고 생각했었는데, React로 실무를 하다 보니 생각보다 많은 곳에서 패턴이 사용되고 있더라. 특히 상태 관리나 컴포넌트 설계에서 패턴을 이해하고 있으면 코드 리뷰나 설계 논의가 훨씬 수월해진다.

이 글에서는 프론트엔드, 특히 React 환경에서 자주 마주치는 디자인 패턴들을 실제 코드와 함께 정리해보려고 한다.

## 디자인 패턴, 왜 알아야 할까?

디자인 패턴은 반복되는 설계 문제에 대한 검증된 해결책이다. "이런 상황에서는 보통 이렇게 해결한다"는 일종의 레시피 같은 것이라고 보면 된다.

실무에서 패턴을 알고 있으면 좋은 점:

- 팀원과 소통할 때 "이 부분 싱글톤으로 관리하면 어때요?"처럼 공통 언어로 대화할 수 있다
- 라이브러리 내부 구조를 이해하기 쉬워진다 (Redux는 옵저버, React Query는 전략 패턴 등)
- 비슷한 문제를 만났을 때 매번 고민하지 않고 검증된 방식으로 빠르게 해결할 수 있다

다만 주의할 점은, 패턴은 "도구"이지 "목적"이 아니라는 것이다. 무조건 패턴을 적용하려다 보면 오히려 코드가 복잡해질 수 있다. 필요한 곳에 적절히 사용하는 게 중요하다.

## 1. 싱글톤 패턴 - 전역에서 하나만 존재해야 하는 인스턴스

### 언제 필요할까?

API 클라이언트, 로거, 설정 관리자처럼 앱 전체에서 딱 하나만 존재하면 되는 객체가 있다. 매번 새로 만들 필요도 없고, 여러 개가 존재하면 오히려 문제가 될 수 있는 경우다.

### 실제 구현

```ts
// lib/apiClient.ts
class ApiClient {
  private static instance: ApiClient | null = null
  private baseUrl: string

  private constructor() {
    this.baseUrl = process.env.NEXT_PUBLIC_API_BASE_URL ?? ''
  }

  static getInstance(): ApiClient {
    if (!ApiClient.instance) {
      ApiClient.instance = new ApiClient()
    }
    return ApiClient.instance
  }

  async get<T>(endpoint: string, options?: RequestInit): Promise<T> {
    const response = await fetch(`${this.baseUrl}${endpoint}`, {
      ...options,
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
      },
    })

    if (!response.ok) {
      throw new Error(`API Error: ${response.status}`)
    }

    return response.json()
  }

  async post<T>(
    endpoint: string,
    data: unknown,
    options?: RequestInit,
  ): Promise<T> {
    const response = await fetch(`${this.baseUrl}${endpoint}`, {
      ...options,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
      },
      body: JSON.stringify(data),
    })

    if (!response.ok) {
      throw new Error(`API Error: ${response.status}`)
    }

    return response.json()
  }
}

export const apiClient = ApiClient.getInstance()
```

```ts
// hooks/usePosts.ts
import { useEffect, useState } from 'react'
import { apiClient } from '@/lib/apiClient'

interface Post {
  id: number
  title: string
  content: string
}

export function usePosts() {
  const [posts, setPosts] = useState<Post[]>([])
  const [isLoading, setIsLoading] = useState(true)
  const [error, setError] = useState<Error | null>(null)

  useEffect(() => {
    apiClient
      .get<Post[]>('/posts')
      .then(setPosts)
      .catch(setError)
      .finally(() => setIsLoading(false))
  }, [])

  return { posts, isLoading, error }
}
```

### 실무에서 만난 문제들

처음에 싱글톤으로 API 클라이언트를 만들었을 때 테스트에서 애를 먹었다. Jest에서 테스트 간에 인스턴스가 공유되면서 테스트가 서로 영향을 주는 문제가 발생했다.

**해결 방법 1: 테스트마다 모듈 리셋**

```ts
// __tests__/apiClient.test.ts
beforeEach(() => {
  jest.resetModules()
})
```

**해결 방법 2: 의존성 주입으로 전환**

```ts
// lib/apiClient.ts
export function createApiClient(baseUrl: string) {
  return {
    async get<T>(endpoint: string): Promise<T> {
      // ...
    },
  }
}

// 프로덕션
export const apiClient = createApiClient(
  process.env.NEXT_PUBLIC_API_BASE_URL ?? '',
)

// 테스트
const mockClient = createApiClient('http://test-api.com')
```

또 하나 주의할 점은 Next.js App Router에서다. 서버 컴포넌트와 클라이언트 컴포넌트의 경계가 명확하지 않으면, 싱글톤이 서버와 클라이언트에서 각각 생성되어 예상과 다르게 동작할 수 있다. 이럴 때는 `'use client'` 지시어를 명확히 사용하거나, Context API로 감싸서 범위를 제한하는 게 좋다.

## 2. 팩토리 패턴 - 객체 생성 로직의 캡슐화

### 언제 필요할까?

디자인 시스템을 만들다 보면 비슷한데 조금씩 다른 컴포넌트를 여러 개 만들게 된다. 예를 들어 Primary Button, Secondary Button, Ghost Button... 이런 식으로 말이다. 각각을 별도 컴포넌트로 만들면 중복 코드가 많아지고, 하나의 거대한 컴포넌트에 조건문으로 처리하면 읽기 어려워진다.

팩토리 패턴을 쓰면 "생성 방식"을 분리해서 깔끔하게 관리할 수 있다.

### 실제 구현

```tsx
// components/Button/buttonFactory.tsx
import { ButtonHTMLAttributes, ReactNode } from 'react'

type ButtonVariant = 'primary' | 'secondary' | 'ghost' | 'danger'
type ButtonSize = 'sm' | 'md' | 'lg'

interface ButtonConfig {
  variant: ButtonVariant
  size?: ButtonSize
}

const variantStyles: Record<ButtonVariant, string> = {
  primary: 'bg-blue-600 text-white hover:bg-blue-700 active:bg-blue-800',
  secondary:
    'bg-gray-100 text-gray-900 hover:bg-gray-200 border border-gray-300',
  ghost: 'bg-transparent text-gray-700 hover:bg-gray-100',
  danger: 'bg-red-600 text-white hover:bg-red-700 active:bg-red-800',
}

const sizeStyles: Record<ButtonSize, string> = {
  sm: 'px-3 py-1.5 text-sm',
  md: 'px-4 py-2 text-base',
  lg: 'px-6 py-3 text-lg',
}

const baseStyles =
  'inline-flex items-center justify-center rounded-md font-medium transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed'

export function createButton({ variant, size = 'md' }: ButtonConfig) {
  return function Button({
    children,
    className = '',
    ...props
  }: ButtonHTMLAttributes<HTMLButtonElement> & { children: ReactNode }) {
    const classes = [
      baseStyles,
      variantStyles[variant],
      sizeStyles[size],
      className,
    ].join(' ')

    return (
      <button className={classes} {...props}>
        {children}
      </button>
    )
  }
}
```

```tsx
// components/Button/index.tsx
import { createButton } from './buttonFactory'

export const PrimaryButton = createButton({ variant: 'primary' })
export const SecondaryButton = createButton({ variant: 'secondary' })
export const GhostButton = createButton({ variant: 'ghost' })
export const DangerButton = createButton({ variant: 'danger' })

// 사이즈 변형도 가능
export const SmallPrimaryButton = createButton({
  variant: 'primary',
  size: 'sm',
})
export const LargeDangerButton = createButton({ variant: 'danger', size: 'lg' })
```

```tsx
// app/components/CTASection.tsx
import { PrimaryButton, GhostButton } from '@/components/Button'

export function CTASection() {
  const handleSignup = () => {
    // 회원가입 로직
  }

  const handleLearnMore = () => {
    // 자세히 보기 로직
  }

  return (
    <section className="flex flex-col items-center gap-4 py-12">
      <h2 className="text-3xl font-bold">지금 시작하세요</h2>
      <div className="flex gap-3">
        <PrimaryButton onClick={handleSignup}>무료로 시작하기</PrimaryButton>
        <GhostButton onClick={handleLearnMore}>자세히 보기</GhostButton>
      </div>
    </section>
  )
}
```

### 실무 팁

이 패턴을 Storybook과 함께 쓰면 효과가 배가 된다. 모든 버튼 변형을 자동으로 문서화할 수 있기 때문이다.

```tsx
// Button.stories.tsx
import type { Meta, StoryObj } from '@storybook/react'
import {
  PrimaryButton,
  SecondaryButton,
  GhostButton,
  DangerButton,
} from './index'

const meta: Meta<typeof PrimaryButton> = {
  title: 'Components/Button',
  component: PrimaryButton,
}

export default meta

export const Primary: StoryObj<typeof PrimaryButton> = {
  args: {
    children: 'Primary Button',
  },
}

export const Secondary: StoryObj<typeof SecondaryButton> = {
  render: () => <SecondaryButton>Secondary Button</SecondaryButton>,
}

// ... 다른 변형들
```

실제로 디자인 시스템 작업할 때 이 방식으로 30개가 넘는 버튼 변형을 관리했는데, 새로운 디자이너가 합류했을 때 Storybook만 보고도 어떤 버튼들이 있는지 한눈에 파악할 수 있어서 온보딩이 정말 빨랐다.

## 3. 전략 패턴 - 런타임에 알고리즘 교체하기

### 언제 필요할까?

폼 입력 포맷팅을 예로 들어보자. 전화번호 입력 필드에서는 "010-1234-5678" 형태로, 가격 입력 필드에서는 "1,000,000원" 형태로 표시하고 싶다. 각 필드마다 다른 컴포넌트를 만들 수도 있지만, 포맷팅 로직만 교체 가능하도록 만들면 훨씬 유연하다.

### 실제 구현

```ts
// lib/formatStrategies.ts
export type FormatStrategy = (value: string) => string

export const phoneFormatter: FormatStrategy = (value) => {
  const numbers = value.replace(/[^0-9]/g, '')

  if (numbers.length <= 3) return numbers
  if (numbers.length <= 7) return `${numbers.slice(0, 3)}-${numbers.slice(3)}`
  return `${numbers.slice(0, 3)}-${numbers.slice(3, 7)}-${numbers.slice(7, 11)}`
}

export const priceFormatter: FormatStrategy = (value) => {
  const numbers = value.replace(/[^0-9]/g, '')
  if (!numbers) return ''

  return new Intl.NumberFormat('ko-KR').format(Number(numbers))
}

export const cardNumberFormatter: FormatStrategy = (value) => {
  const numbers = value.replace(/[^0-9]/g, '')
  const chunks = numbers.match(/.{1,4}/g) || []
  return chunks.join('-').slice(0, 19) // 16자리 + 하이픈 3개
}

export const businessNumberFormatter: FormatStrategy = (value) => {
  const numbers = value.replace(/[^0-9]/g, '')

  if (numbers.length <= 3) return numbers
  if (numbers.length <= 5) return `${numbers.slice(0, 3)}-${numbers.slice(3)}`
  return `${numbers.slice(0, 3)}-${numbers.slice(3, 5)}-${numbers.slice(5, 10)}`
}

type StrategyType = 'phone' | 'price' | 'card' | 'business'

const strategies: Record<StrategyType, FormatStrategy> = {
  phone: phoneFormatter,
  price: priceFormatter,
  card: cardNumberFormatter,
  business: businessNumberFormatter,
}

export function getFormatStrategy(type: StrategyType): FormatStrategy {
  return strategies[type]
}
```

```ts
// hooks/useFormattedInput.ts
import { useState, ChangeEvent } from 'react'
import { getFormatStrategy } from '@/lib/formatStrategies'

type FormatType = 'phone' | 'price' | 'card' | 'business'

export function useFormattedInput(type: FormatType, initialValue = '') {
  const [value, setValue] = useState(initialValue)
  const [rawValue, setRawValue] = useState(initialValue.replace(/[^0-9]/g, ''))

  const formatter = getFormatStrategy(type)

  const handleChange = (e: ChangeEvent<HTMLInputElement>) => {
    const input = e.target.value
    const formatted = formatter(input)
    const raw = input.replace(/[^0-9]/g, '')

    setValue(formatted)
    setRawValue(raw)
  }

  const reset = () => {
    setValue('')
    setRawValue('')
  }

  return {
    value,
    rawValue,
    handleChange,
    reset,
  }
}
```

```tsx
// components/FormField.tsx
import { useFormattedInput } from '@/hooks/useFormattedInput'

export function PhoneField() {
  const { value, rawValue, handleChange } = useFormattedInput('phone')

  return (
    <div className="flex flex-col gap-1">
      <label className="text-sm font-medium text-gray-700">전화번호</label>
      <input
        type="text"
        value={value}
        onChange={handleChange}
        placeholder="010-1234-5678"
        className="rounded-md border border-gray-300 px-3 py-2"
      />
      <p className="text-xs text-gray-500">실제 전송될 값: {rawValue}</p>
    </div>
  )
}

export function PriceField() {
  const { value, rawValue, handleChange } = useFormattedInput('price')

  return (
    <div className="flex flex-col gap-1">
      <label className="text-sm font-medium text-gray-700">가격</label>
      <div className="relative">
        <input
          type="text"
          value={value}
          onChange={handleChange}
          placeholder="1,000,000"
          className="w-full rounded-md border border-gray-300 px-3 py-2 pr-8"
        />
        <span className="absolute right-3 top-1/2 -translate-y-1/2 text-gray-500">
          원
        </span>
      </div>
      <p className="text-xs text-gray-500">숫자 값: {rawValue}</p>
    </div>
  )
}
```

### 실무에서의 확장

전략 패턴은 validation에도 적용할 수 있다. 실제로 프로젝트에서 다음과 같이 확장해서 사용했다.

```ts
// lib/validationStrategies.ts
export type ValidationStrategy = (value: string) => {
  isValid: boolean
  message: string
}

export const phoneValidator: ValidationStrategy = (value) => {
  const numbers = value.replace(/[^0-9]/g, '')

  if (numbers.length === 0) {
    return { isValid: false, message: '전화번호를 입력해주세요.' }
  }

  if (numbers.length !== 11) {
    return { isValid: false, message: '올바른 전화번호 형식이 아닙니다.' }
  }

  if (!numbers.startsWith('010')) {
    return { isValid: false, message: '010으로 시작하는 번호만 가능합니다.' }
  }

  return { isValid: true, message: '' }
}

export const priceValidator: ValidationStrategy = (value) => {
  const numbers = value.replace(/[^0-9]/g, '')
  const price = Number(numbers)

  if (numbers.length === 0) {
    return { isValid: false, message: '가격을 입력해주세요.' }
  }

  if (price < 1000) {
    return { isValid: false, message: '최소 금액은 1,000원입니다.' }
  }

  if (price > 10000000) {
    return { isValid: false, message: '최대 금액은 10,000,000원입니다.' }
  }

  return { isValid: true, message: '' }
}
```

이렇게 포맷팅과 validation을 전략 패턴으로 분리하니 새로운 필드 타입을 추가할 때 기존 코드를 거의 건드리지 않아도 됐다.

## 4. 옵저버 패턴 - 상태 변화를 구독하고 반응하기

### 언제 필요할까?

옵저버 패턴은 사실 React를 쓰는 사람이라면 이미 매일 사용하고 있는 패턴이다. `useState`, `useEffect`, 상태 관리 라이브러리들이 모두 옵저버 패턴을 기반으로 한다.

하지만 직접 구현해야 할 때도 있다. 예를 들어 Server-Sent Events로 실시간 알림을 받거나, WebSocket 연결을 관리하거나, 여러 컴포넌트가 같은 데이터 변화를 감지해야 할 때다.

### 실제 구현 - Server-Sent Events

```ts
// hooks/useServerSentEvents.ts
import { useEffect, useState, useCallback } from 'react'

interface UseSSEOptions {
  onOpen?: () => void
  onError?: (error: Event) => void
  reconnect?: boolean
  reconnectInterval?: number
}

export function useServerSentEvents<T>(
  url: string,
  options: UseSSEOptions = {},
) {
  const [data, setData] = useState<T | null>(null)
  const [isConnected, setIsConnected] = useState(false)
  const [error, setError] = useState<Event | null>(null)

  const {
    onOpen,
    onError,
    reconnect = true,
    reconnectInterval = 3000,
  } = options

  useEffect(() => {
    let eventSource: EventSource | null = null
    let reconnectTimeout: NodeJS.Timeout

    const connect = () => {
      eventSource = new EventSource(url)

      eventSource.onopen = () => {
        setIsConnected(true)
        setError(null)
        onOpen?.()
      }

      eventSource.onmessage = (event) => {
        try {
          const parsedData = JSON.parse(event.data) as T
          setData(parsedData)
        } catch (err) {
          console.error('Failed to parse SSE data:', err)
        }
      }

      eventSource.onerror = (event) => {
        setIsConnected(false)
        setError(event)
        onError?.(event)

        eventSource?.close()

        if (reconnect) {
          reconnectTimeout = setTimeout(connect, reconnectInterval)
        }
      }
    }

    connect()

    return () => {
      eventSource?.close()
      clearTimeout(reconnectTimeout)
    }
  }, [url, onOpen, onError, reconnect, reconnectInterval])

  return { data, isConnected, error }
}
```

```tsx
// components/NotificationBell.tsx
'use client'

import { useServerSentEvents } from '@/hooks/useServerSentEvents'
import { useState } from 'react'

interface Notification {
  id: string
  type: 'info' | 'success' | 'warning' | 'error'
  title: string
  message: string
  createdAt: string
}

export function NotificationBell() {
  const [notifications, setNotifications] = useState<Notification[]>([])
  const [isOpen, setIsOpen] = useState(false)

  const { data: newNotification, isConnected } =
    useServerSentEvents<Notification>('/api/notifications/stream', {
      onOpen: () => {
        console.log('알림 스트림에 연결되었습니다.')
      },
      onError: (error) => {
        console.error('알림 스트림 연결 오류:', error)
      },
    })

  // 새 알림이 도착하면 목록에 추가
  useEffect(() => {
    if (newNotification) {
      setNotifications((prev) => [newNotification, ...prev].slice(0, 10))
    }
  }, [newNotification])

  const unreadCount = notifications.filter((n) => !n.read).length

  return (
    <div className="relative">
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="relative rounded-full p-2 hover:bg-gray-100"
      >
        <BellIcon className="h-6 w-6" />
        {unreadCount > 0 && (
          <span className="absolute right-1 top-1 flex h-4 w-4 items-center justify-center rounded-full bg-red-500 text-xs text-white">
            {unreadCount > 9 ? '9+' : unreadCount}
          </span>
        )}
        {!isConnected && (
          <span className="absolute bottom-1 right-1 h-2 w-2 rounded-full bg-yellow-500" />
        )}
      </button>

      {isOpen && (
        <div className="absolute right-0 top-12 w-80 rounded-lg border border-gray-200 bg-white shadow-lg">
          <div className="border-b p-4">
            <h3 className="font-semibold">알림</h3>
          </div>
          <div className="max-h-96 overflow-y-auto">
            {notifications.length === 0 ? (
              <p className="p-4 text-center text-gray-500">
                새로운 알림이 없습니다.
              </p>
            ) : (
              notifications.map((notification) => (
                <NotificationItem
                  key={notification.id}
                  notification={notification}
                />
              ))
            )}
          </div>
        </div>
      )}
    </div>
  )
}
```

### 실무 팁 - useSyncExternalStore 활용

React 18부터는 외부 스토어(EventEmitter, RxJS 등)와 동기화할 때 `useSyncExternalStore`를 사용하는 게 권장된다. 이전에 커스텀 옵저버를 만들었을 때 tearing 문제(같은 상태를 구독하는 컴포넌트들이 다른 값을 표시)가 발생했었는데, 이 Hook을 쓰니 해결됐다.

```ts
// lib/notificationStore.ts
type Listener = () => void

class NotificationStore {
  private listeners = new Set<Listener>()
  private notifications: Notification[] = []

  subscribe(listener: Listener) {
    this.listeners.add(listener)
    return () => this.listeners.delete(listener)
  }

  getSnapshot() {
    return this.notifications
  }

  addNotification(notification: Notification) {
    this.notifications = [notification, ...this.notifications]
    this.listeners.forEach((listener) => listener())
  }
}

export const notificationStore = new NotificationStore()
```

```tsx
// hooks/useNotifications.ts
import { useSyncExternalStore } from 'react'
import { notificationStore } from '@/lib/notificationStore'

export function useNotifications() {
  const notifications = useSyncExternalStore(
    notificationStore.subscribe.bind(notificationStore),
    notificationStore.getSnapshot.bind(notificationStore),
    notificationStore.getSnapshot.bind(notificationStore), // SSR용
  )

  return notifications
}
```

이렇게 하면 여러 컴포넌트에서 `useNotifications()`를 호출해도 항상 일관된 상태를 보장받을 수 있다.

## 5. 프록시 패턴 - 접근을 제어하고 추가 기능 제공하기

### 언제 필요할까?

API 요청마다 인증 토큰을 자동으로 추가하거나, 로깅을 하거나, 캐싱을 하거나... 원본 객체에 직접 접근하기 전에 뭔가 전처리가 필요할 때 프록시 패턴이 유용하다.

JavaScript의 `Proxy` 객체를 사용하면 이를 쉽게 구현할 수 있다.

### 실제 구현 - API 요청 래퍼

```ts
// lib/apiClientWithProxy.ts
interface ApiRequest {
  endpoint: string
  options?: RequestInit
}

interface ApiResponse<T> {
  data: T
  status: number
  timestamp: number
}

class BaseApiClient {
  constructor(private baseUrl: string) {}

  async request<T>(
    endpoint: string,
    options?: RequestInit,
  ): Promise<ApiResponse<T>> {
    const response = await fetch(`${this.baseUrl}${endpoint}`, options)

    return {
      data: await response.json(),
      status: response.status,
      timestamp: Date.now(),
    }
  }
}

// 프록시로 감싸서 자동으로 토큰 추가, 로깅, 에러 처리
export function createApiClientProxy(baseUrl: string) {
  const client = new BaseApiClient(baseUrl)

  return new Proxy(client, {
    get(target, prop) {
      if (prop === 'request') {
        return async function <T>(endpoint: string, options?: RequestInit) {
          // 요청 전 처리
          const token = localStorage.getItem('auth_token')
          const enhancedOptions: RequestInit = {
            ...options,
            headers: {
              ...options?.headers,
              ...(token && { Authorization: `Bearer ${token}` }),
            },
          }

          console.log(`[API] ${options?.method || 'GET'} ${endpoint}`)
          const startTime = Date.now()

          try {
            const result = await target.request<T>(endpoint, enhancedOptions)

            // 응답 후 처리
            const duration = Date.now() - startTime
            console.log(`[API] ✓ ${endpoint} (${duration}ms)`)

            return result
          } catch (error) {
            // 에러 처리
            const duration = Date.now() - startTime
            console.error(`[API] ✗ ${endpoint} (${duration}ms)`, error)

            // 401 에러시 자동 리다이렉트
            if (error instanceof Response && error.status === 401) {
              window.location.href = '/login'
            }

            throw error
          }
        }
      }

      return Reflect.get(target, prop)
    },
  })
}

export const apiClient = createApiClientProxy(
  process.env.NEXT_PUBLIC_API_BASE_URL ?? '',
)
```

### 실무 활용 - 불변 상태 보장

개발 중에 실수로 상태를 직접 수정하는 걸 방지하기 위해 프록시를 사용할 수도 있다.

```ts
// lib/immutableProxy.ts
export function createImmutableProxy<T extends object>(
  obj: T,
  name = 'state',
): T {
  return new Proxy(obj, {
    set() {
      throw new Error(
        `${name}는 직접 수정할 수 없습니다. setState를 사용하세요.`,
      )
    },
    get(target, prop) {
      const value = Reflect.get(target, prop)

      // 중첩된 객체도 프록시로 감싸기
      if (value && typeof value === 'object') {
        return createImmutableProxy(value, `${name}.${String(prop)}`)
      }

      return value
    },
  })
}

// 사용 예시
const state = createImmutableProxy({ user: { name: '홍길동', age: 30 } })

console.log(state.user.name) // "홍길동"
state.user.age = 31 // Error: state.user는 직접 수정할 수 없습니다.
```

실제로 팀 프로젝트에서 이 패턴을 도입했더니 Redux를 거치지 않고 상태를 직접 수정하는 실수가 확 줄었다. 특히 신입 개발자들이 합류했을 때 도움이 많이 됐다.

## 패턴 적용 시 내가 배운 것들

### 1. 패턴은 만능이 아니다

예전에 "좋은 코드 = 디자인 패턴을 많이 쓴 코드"라고 착각했던 적이 있다. 작은 유틸 함수에도 팩토리 패턴을 적용하고, 단순한 컴포넌트에도 전략 패턴을 끼워 넣었다. 결과는? 코드는 복잡해지고, 팀원들은 이해하기 어려워했고, 유지보수는 더 힘들어졌다.

패턴은 "문제를 해결하기 위한 도구"다. 문제가 없는데 패턴을 억지로 적용하면 오히려 독이 된다.

### 2. 팀과의 합의가 중요하다

디자인 패턴을 도입할 때는 반드시 팀과 논의해야 한다. 특히 공용 컴포넌트나 핵심 라이브러리에 패턴을 적용할 때는 더욱 그렇다.

우리 팀은 다음과 같은 규칙을 정했다:

- 새로운 패턴 도입 시 짧은 기술 문서 작성 (왜 필요한지, 어떻게 쓰는지)
- 코드 리뷰에서 패턴 이름으로 소통 ("이 부분 팩토리 패턴으로 분리하면 어때요?")
- 패턴이 복잡도를 높이는지 주기적으로 회고

### 3. 테스트 용이성을 고려하라

디자인 패턴을 적용하면서 가장 큰 이득은 테스트가 쉬워진다는 것이었다. 특히 의존성 주입(DI)과 함께 사용하면 효과가 배가 된다.

```ts
// 좋지 않은 예 - 테스트하기 어려움
export function fetchUserData() {
  const token = localStorage.getItem('token')
  return fetch('/api/user', {
    headers: { Authorization: `Bearer ${token}` },
  })
}

// 개선된 예 - 의존성을 주입받아 테스트 가능
export function createUserService(storage: Storage, apiClient: ApiClient) {
  return {
    async fetchUserData() {
      const token = storage.getItem('token')
      return apiClient.get('/user', {
        headers: { Authorization: `Bearer ${token}` },
      })
    },
  }
}

// 테스트
const mockStorage = { getItem: jest.fn(() => 'fake-token') }
const mockApiClient = { get: jest.fn() }
const service = createUserService(mockStorage, mockApiClient)
```

### 4. Next.js 환경에서의 주의사항

Next.js App Router를 쓰면서 배운 건, 서버 컴포넌트와 클라이언트 컴포넌트의 경계를 명확히 해야 한다는 것이다.

예를 들어 싱글톤 패턴을 쓸 때:

- 서버에서만 쓰인다면 문제없다
- 클라이언트에서만 쓰인다면 `'use client'` 명시
- 둘 다에서 쓰인다면? → Context API나 Provider로 범위를 제한하자

```tsx
// providers/ApiClientProvider.tsx
'use client'

import { createContext, useContext, ReactNode } from 'react'
import { createApiClient } from '@/lib/apiClient'

const ApiClientContext = createContext(null)

export function ApiClientProvider({ children }: { children: ReactNode }) {
  const client = useMemo(
    () => createApiClient(process.env.NEXT_PUBLIC_API_BASE_URL),
    [],
  )

  return (
    <ApiClientContext.Provider value={client}>
      {children}
    </ApiClientContext.Provider>
  )
}

export function useApiClient() {
  const client = useContext(ApiClientContext)
  if (!client) throw new Error('ApiClientProvider가 필요합니다.')
  return client
}
```

## 마치며

디자인 패턴은 마법이 아니다. 그냥 많은 개발자들이 비슷한 문제를 겪으면서 정리한 "이렇게 하면 괜찮더라"는 노하우 모음집이다.

중요한 건 패턴의 이름을 외우는 게 아니라:

- 이 패턴이 어떤 문제를 해결하는지
- 내 프로젝트에 그 문제가 있는지
- 적용했을 때 얻는 이득이 복잡도 증가보다 큰지

를 판단하는 능력이다.

이 글을 쓰면서 내가 실무에서 패턴을 어떻게 활용했는지 되돌아볼 수 있어서 좋았다. 여러분도 패턴을 공부할 때 "이게 어떤 상황에 필요할까?"를 먼저 고민해보길 추천한다. 그럼 단순히 이론을 암기하는 게 아니라 진짜 내 것으로 만들 수 있을 것이다.

---

**참고한 책**

- 면접을 위한 CS 전공 지식 노트
