---
title: '컴퓨터 사이언스 CS 공부 - 디자인 패턴'
date: '2025-11-10'
description: 'CS 공부 시리즈 중 첫 번째로 디자인 패턴에 대해 알아봅니다.'
tags: ['개발','CS']
thumbnail: '/images/2025/1/BlogThumbnail.png'
---

`면접을 위한 CS 전공 지식 노트` 책을 읽고 정리한 내용에 프론트엔드(특히 React)에서 마주치는 사례와 간단한 예시 코드를 더해, 디자인 패턴을 실무 관점에서 정리합니다.  

## 1. 디자인 패턴이란?

소프트웨어 설계 시 반복적으로 등장하는 문제를 해결하기 위해 공통적으로 사용할 수 있는 구조적 해법을 **디자인 패턴**이라고 합니다.  
패턴을 적절히 활용하면 협업 시 의사소통이 쉬워지고, 유지보수성과 재사용성이 향상되며, 성능·테스트 전략을 예측하기 쉬워집니다. 프론트엔드에서도 상태 관리, 컴포넌트 구조화, 비동기 처리 등에서 디자인 패턴을 자주 활용합니다.

>  **TIP**  
> 패턴은 “틀”이 아니라 “문제 해결에 쓰이는 개념”입니다. 프로젝트 규모나 팀 문화에 맞게 선택적으로 적용하는 것이 중요합니다.

## 2. 프론트엔드에서 자주 쓰이는 디자인 패턴

### 2.1 싱글톤 패턴

- **정의**: 애플리케이션 전체에서 인스턴스를 하나만 유지하는 패턴.
- **장점**: 인스턴스 생성 비용 절약, 전역 상태 공유 용이.
- **주의**: 전역 상태가 복잡해지면 테스트가 어려워지고 결합도가 높아짐.

#### React 예시: API 클라이언트를 싱글톤으로 관리

```ts
// apiClient.ts
class ApiClient {
  private static instance: ApiClient | null = null;

  private constructor(private readonly baseUrl: string) {}

  static getInstance() {
    if (!this.instance) {
      this.instance = new ApiClient(process.env.NEXT_PUBLIC_API_BASE_URL ?? '');
    }
    return this.instance;
  }

  async get<T>(path: string): Promise<T> {
    const res = await fetch(`${this.baseUrl}${path}`);
    return res.json();
  }
}

export const apiClient = ApiClient.getInstance();
// usePosts.ts
import { useEffect, useState } from 'react';
import { apiClient } from './apiClient';

export function usePosts() {
  const [posts, setPosts] = useState([]);

  useEffect(() => {
    apiClient.get('/posts').then(setPosts);
  }, []);

  return posts;
}
```

#### 실전 팁
- Next.js `App Router`에서 서버-클라이언트 경계가 명확하지 않을 경우 싱글톤이 의도치 않은 상태 공유를 만들 수 있습니다. Context API로 감싸고 `React.StrictMode`에 따른 두 번 렌더링 이슈도 고려하세요.
- Jest 테스트에서는 `beforeEach`에서 `jest.resetModules()`로 캐시를 초기화하거나, DI(의존성 주입) 방식으로 전환하면 테스트가 쉬워집니다.

### 2.2 팩토리 패턴

- **정의**: 객체 생성 로직을 별도 팩토리로 캡슐화하여, 호출자는 “무엇을 만들지”만 결정하고 “어떻게”는 숨기는 패턴.
- **장점**: 조건 분기 없이 다양한 변형 객체를 만들 수 있고, 추상화 수준을 유지하면서 확장 가능.
- **프론트 활용**: 상황별로 다른 UI 컴포넌트나 상태 관리 객체를 생성할 때 유용.

#### React 예시: 버튼 스타일 변형을 팩토리로 분리

```ts

// buttonFactory.tsx
import { ButtonHTMLAttributes } from 'react';

type Variant = 'primary' | 'secondary' | 'ghost';

const BASE_CLASS = 'inline-flex items-center justify-center rounded px-4 py-2';

const variantClassMap: Record<Variant, string> = {
  primary: `${BASE_CLASS} bg-blue-500 text-white hover:bg-blue-600`,
  secondary: `${BASE_CLASS} border border-gray-300 text-gray-700`,
  ghost: `${BASE_CLASS} bg-transparent text-gray-500 hover:bg-gray-100`,
};

export function createButton(variant: Variant) {
  return function Button(props: ButtonHTMLAttributes<HTMLButtonElement>) {
    return <button className={variantClassMap[variant]} {...props} />;
  };
}
// Buttons.tsx
import { createButton } from './buttonFactory';

const PrimaryButton = createButton('primary');
const GhostButton = createButton('ghost');

export function CTASection() {
  return (
    <div className="flex gap-2">
      <PrimaryButton onClick={() => alert('가입하러 가기!')}>가입</PrimaryButton>
      <GhostButton onClick={() => alert('조금 더 알아볼게요')}>자세히 보기</GhostButton>
    </div>
  );
}
```
#### 실전 팁
- 디자인 시스템에서 변형이 많아질수록 팩토리 패턴이나 `component config object`를 도입하면 레이아웃 복잡도를 줄일 수 있습니다.
- 스토리북과 함께 사용하면 변형별 컬러, 사이즈, 아이콘 등을 자동 문서화하기 좋습니다.

### 2.3 전략 패턴

- **정의**: 행동(알고리즘)을 캡슐화한 뒤 런타임에 교체 가능하도록 구성하는 패턴.
- **장점**: 다양한 정책을 상황에 따라 교체할 수 있어 확장성이 뛰어남.
- **프론트 활용**: 폼 검증 전략, 권한 부여 정책, A/B 테스트 등.

#### React 예시: 입력 값 포매터를 전략으로 교체

```ts
// formatStrategies.ts
type FormatStrategy = (value: string) => string;

export const phoneFormatter: FormatStrategy = value =>
  value.replace(/[^0-9]/g, '').replace(/(\d{3})(\d{4})(\d{4})/, '$1-$2-$3');

export const priceFormatter: FormatStrategy = value =>
  Intl.NumberFormat('ko-KR').format(Number(value.replace(/[^0-9]/g, '')));

export function getFormatStrategy(type: 'phone' | 'price'): FormatStrategy {
  const strategies = {
    phone: phoneFormatter,
    price: priceFormatter,
  };
  return strategies[type];
}
// useFormattedInput.ts
import { useState } from 'react';
import { getFormatStrategy } from './formatStrategies';

export function useFormattedInput(type: 'phone' | 'price') {
  const [value, setValue] = useState('');
  const formatter = getFormatStrategy(type);

  const handleChange = (input: string) => {
    setValue(formatter(input));
  };

  return { value, handleChange };
}
// FormField.tsx
import { useFormattedInput } from './useFormattedInput';

export function PhoneField() {
  const { value, handleChange } = useFormattedInput('phone');

  return (
    <input
      value={value}
      onChange={event => handleChange(event.target.value)}
      placeholder="010-1234-5678"
    />
  );
}
```
#### 실전 팁
- React Query, Zustand, Redux Toolkit 등에서도 전략 패턴이 내부적으로 사용됩니다. 캐시 정책이나 retry 전략을 인자로 넘기는 구조가 대표적인 예입니다.
- 전략 객체가 많아질수록 명세(인터페이스) 정의를 통해 일관성을 유지하세요.

### 2.4 옵저버 패턴

- **정의**: 주체(Subject)의 상태 변화가 있을 때 옵저버(Observer)에게 알리고, 옵저버가 이를 기반으로 동작하도록 하는 패턴.
- **프론트 활용**: 이벤트 리스너, RxJS 스트림, GraphQL Subscriptions, Zustand/Redux 등 상태 관리.

#### React 예시: `EventSource` + 커스텀 훅으로 옵저버 구현

```ts
// useServerSentEvents.ts
import { useEffect, useState } from 'react';

export function useServerSentEvents<T>(url: string) {
  const [data, setData] = useState<T | null>(null);

  useEffect(() => {
    const eventSource = new EventSource(url);

    eventSource.onmessage = event => {
      setData(JSON.parse(event.data));
    };

    eventSource.onerror = () => {
      eventSource.close();
    };

    return () => eventSource.close();
  }, [url]);

  return data;
}
// Notifications.tsx
import { useServerSentEvents } from './useServerSentEvents';

type Notification = { id: string; message: string; createdAt: string };

export function Notifications() {
  const notification = useServerSentEvents<Notification>('/api/notifications');

  if (!notification) return null;

  return (
    <div className="rounded bg-emerald-100 px-4 py-2">
      {notification.message}
    </div>
  );
}
```
#### 실전 팁
- 옵저버 패턴은 리렌더링 트리거가 잦으므로 `useSyncExternalStore`를 사용하면 최적화 효과가 큽니다.
- EventEmitter 기반 라이브러리를 사용할 때는 구독 해제를 반드시 처리 (`useEffect` cleanup) 해 메모리 누수를 방지하세요.

### 2.5 컴포지트 & 프록시 응용 (추가로 활용하기 좋은 패턴)

- **컴포지트 패턴**: 트리 구조 UI 관리에서 흔하게 사용합니다. 메뉴, 댓글, 폴더 구조 등 재귀 렌더링 컴포넌트 설계 시 자연스럽게 등장합니다.
- **프록시 패턴**: 브라우저 API `Proxy`를 활용해 데이터 액세스를 가로채거나, 네트워크 계층에서 토큰 주입/로깅을 담당하는 래퍼를 만들 수 있습니다.

```ts
const state = { isAdmin: false };

export const guardState = new Proxy(state, {
  get(target, prop) {
    console.log(`읽기 시도: ${String(prop)}`);
    return Reflect.get(target, prop);
  },
  set(target, prop, value) {
    throw new Error(`state는 직접 수정할 수 없습니다. 현재 prop: ${String(prop)}`);
  },
});
```
## 3. 패턴 선택 시 고려사항

- **테스트 전략**: DI(Dependency Injection)와 함께 쓰면 테스트하기 쉬워집니다. 단일 패턴으로 테스트가 어려울 때는 설계를 재검토하세요.
- **팀 합의**: 공용 컴포넌트나 상태 관리 API에 패턴을 도입할 땐 팀의 합의가 필요합니다. 이름이나 파일 구조까지 함께 정의해놓으면 학습 곡선을 줄일 수 있습니다.
- **추상화 비용**: 패턴을 시도했다가 유지보수 비용이 더 커지는 경우도 있습니다. “패턴 적용으로 얻는 이득”이 “추상화 복잡도”보다 큰지 검토하세요.

## 4. 마치며

디자인 패턴은 “도구 상자”와 같습니다. 모든 문제에 한 가지 패턴을 강제로 적용하기보다는, 각 패턴의 목적과 장단점을 이해한 뒤 프로젝트 상황에 맞게 조합해서 사용하는 것이 중요합니다.

- React와 Next.js에서는 파일 기반 라우팅, 서버 컴포넌트, 클라이언트 컴포넌트로 인해 패턴 적용 시 호출 환경을 반드시 확인하세요.
- “패턴의 이름을 공유 언어로 사용한다”는 것만으로도 협업 효율이 높아집니다. 팀 내 코드 리뷰에서 “이 부분은 전략 패턴으로 분리하면 어때요?”라는 식의 대화가 자연스럽게 오고 갈 수 있도록 공동 학습을 추천합니다.

