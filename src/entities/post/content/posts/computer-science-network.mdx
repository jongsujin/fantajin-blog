---
title: '네트워크 기초 정리'
date: '2025-11-21'
description: '네트워크 기초 정리'
tags: ['개발', 'CS', '네트워크']
thumbnail: '/images/2025/1/BlogThumbnail.png'
---

## 0. 시작하기 전에

네트워크는 컴퓨터 및 휴대폰과 같이 우리가 흔히 쓰고 있는 장치들이 통신하는 연결망을 지칭하는 용어입니다.
특히 웹개발자라면 네트워크에 대해서 만큼은 깊이 이해하고 있어야 한다고 생각합니다.

그래서 이번 시리즈는 간단하게 네트워크에 대해 알아보고자 합니다.

## 1. 네트워크란?

네트워크란 `노드(node)와 링크(link)가 서로 연결되어 있는 집합체` 입니다.
여기서 노드란 서버, 라우터 , 스위치 등 네트워크 장치를 의미하고 링크는 유선 또는 무선을 의미합니다.

### 1.1 처리량과 지연 시간

좋은 네트워크가 되기 위해서는 많은 처리량을 처리할 수 있으며, 지연 시간이 짧고 장애 빈도가 적으며 안정적인 보안을 갖춘 네트워크여야 합니다.

`처리량` 은 링크 내에서 성공적으로 전달된 데이터 양을 말합니다. 보통 얼만큼의 트래픽을 처리했는지를 나타냅니다.
단위로는 `bps(bits per second)`을 사용합니다. 그대로 풀이하자면 초당 전송 또는 수신되는 비트 수를 의미합니다.

처리량은 트래픽, 네트워크 장치 간의 대역폭, 네트워크 중간에 발생하는 에러, 장치의 하드웨어 스펙 등의 영향을 받습니다.

흔히 많이 언급하는 트래픽이란 특정 시점에 링크 내에 흐르는 데이터의 양을 말합니다.

다소 헷갈릴 수도 있으나 정리하자면 트래픽이 많아졌다는 것은 현재 흐르는 데이터가 많아졌다는 뜻이며 처리량이 많아졌다라는 말은 처리되는 **트래픽**이 많아졌다는 뜻입니다.

`지연 시간(latency)` 은 데이터 요청이 처리되는 시간을 말하며 어떤 메시지가 두 장치 사이를 왕복하는데 걸린 시간을 말합니다.
지연 시간은 매체 타입(무선 유선 여부), 패킷 크기 등에 영향을 받습니다.

### 1.2 네트워크 토폴리지

네트워크를 설계할 때 고려하는 네트워크 토폴리지란 노드와 링크가 어떻게 배치되어 있는지에 대한 방식이자 연결 형태를 의미합니다.
예를 들어 네트워크 토폴리지에는 아래와 같은 종류가 있습니다.

- 스타 토폴리지 : 중앙에 있는 노드에 모두 연결된 네트워크 구성을 말합니다. 노드 추가 및 에러를 탐지하기 쉬우나, 중앙 노드에 집중되어 있다는 점이 단점입니다.
- 버스 토폴리지 : 중앙 통신 회선 하나에 여러 개의 노드가 연결되어 공유하는 네트워크 구성을 말하며 근거리 통신망(LAN)에서 주로 사용됩니다. 단 `스푸핑`에 취약하다는 단점이 있습니다.
- 링 토폴리지 : 각각의 노드가 양 옆의 두 노드와 연결하여 전체적으로 고리처럼 하나의 연속된 길을 통해 통신을 하는 망 구성 방식입니다.
- 트리 토폴리지 : 계층형 토폴리지라고 하며 트리 형태로 배치한 네트워크 구성을 말합니다. 추가 및 삭제가 용이하며 특정 노드에 트래픽이 집중 될 떄 하위 노드에 영향을 끼칠 수 있습니다.
- 메시 토폴리지 : 망형 토폴로지라고도 하며 그물망처럼 연결되어 있는 구조입니다. 한 단말 장치에 장애가 발생해도 여러 개의 경로가 존재하므로 안정적이지만, 노드 추가이 어렵고 비용이 비싸다는 단점이 있습니다.

위와 같은 토폴리지 설계가 중요한 이유는 **병목 현상**을 찾을 때 중요하게 사용됩니다.
병목 현상이란 특정 노드 또는 링크가 네트워크의 전체 성능을 제한하는 현상을 말합니다.
예를 들어 스타 토폴리지에서 중앙 노드에 트래픽이 집중되면 하위 노드에 영향을 끼칠 수 있습니다.
이러한 병목 현상을 찾아서 해결하는 것이 중요합니다.

### 1.3 네트워크 분류

지금까지 네트워크를 설계하는 토폴리지에 대해 알아봤다면 만들어진 네트워크는 어떻게 분류할 수 있을까요?
흔히 규모를 기반으로 분류합니다.

근거리 통신망인 가벼운 LAN부터 도시 규모인 MAN, 국가 규모인 WAN까지 다양한 규모의 네트워크로 분류할 수 있습니다.

### 1.4 네트워크 프로토콜

네트워크 프로토콜이란 다른 장치들끼리 데이터를 주고 받기 위해 설정된 공통된 인터페이스를 말합니다.
IEEE 또는 IETF 같은 표준 기구에서 정의한 프로토콜을 말합니다.

## 2. TCP/IP 4계층 모델이란?

지금까지 네트워크의 기본 개념을 살펴봤다면,
이제 실제 인터넷이 어떤 구조로 데이터를 주고받는지 이해할 차례입니다.
현대 인터넷의 기반이 되는 표준 모델, TCP/IP 4계층 모델을 살펴보겠습니다.

### 2.1 계층 구조

TCP/IP 4계층 모델은 계층 구조로 나누어지며, OSI 7계층 모델과 많이 비교됩니다.
아래 사진처럼 위 구조는 특정 계층이 변경되었을 때 다른 계층이 영향을 받지 않도록 설계 되었습니다.
그럼 각 계층별로 간단하게 설명해보도록 하겠습니다.

![image](/images/2025/13/tcp.png)

### 2.2 애플리케이션 계층

애플리케이션 계층은 FTP , HTTP , SSH, SMTP , DNS 등 응용 프로그램이 사용되는 프로토콜 계층이며 웹 서비스, 이메일 등 실질적으로 사용자들에게 제공하는 층입니다.

### 2,2 전송 계층

전송 계층은 송신자와 수신자를 연결하는 통신 서비스를 제공하며 애플리케이션과 인터넷 계층 사이에서 중재자 역할을 합니다. TCP, UDP 프로토콜이 이 계층에서 사용됩니다.

- TCP : 패킷 사이의 순서를 보장하고 연결지향 프로토콜을 사용해서 연결을 하여 신뢰성을 높이는 `가상회선 패킷 교환 방식` 을 사용합니다.
- UDP : 순서를 보장하지 않고 수신 여부를 확인하지 않으며 단순히 데이터만 주는 `데이터그램 패킷 교환 방식` 을 사용합니다.

**패킷** 이란 네트워크 상에서 전달되는 데이터의 최소 단위를 말합니다.
패킷은 헤더와 바디로 구성되며 헤더에는 패킷의 출발지와 도착지, 패킷의 크기 등의 정보가 포함되어 있습니다.
바디에는 실제 전송되는 데이터가 포함되어 있습니다.

#### 2.2.1 가상회선 패킷 교환 방식

가상회선 패킷 교환 방식은 각 패킷에는 가상회선 식별자가 포함되며, 모든 패킷을 전송하면 가상회선이 해제되고 패킷들은 전송된 '순서대로' 도착하는 방식을 말합니다.
따라서 신뢰성을 보장할 수 있는 TCP 프로토콜에 사용됩니다.

#### 2.2.2 데이터그램 패킷 교환 방식

데이터그램 패킷 교환 방식은 패킷이 독립적으로 이동하며 최적의 경로를 선택하며 가는데, 하나의 메시지에서 분할된 여러 패킷은 서로 다른 경로로 전송될 수 있으며 도착한 '순서가 다를 수 있는' 방식을 뜻합니다.
따라서 신뢰성을 보장하지 않는 UDP 프로토콜에 사용됩니다.

#### 2.2.3 TCP 연결 과정

TCP는 신뢰성을 확보할 때 `3-way handshake` 과정을 통해 연결을 설정합니다.
이 과정은 아래와 같습니다.

1. 클라이언트가 서버에 연결 요청(SYN)을 보냅니다.
2. 서버가 클라이언트에 연결 요청(SYN)에 대한 응답(SYN, ACK)을 보냅니다.
3. 클라이언트가 서버에 연결 요청(SYN, ACK)에 대한 응답(ACK)을 보냅니다.

이 과정을 통해 클라이언트와 서버가 연결됩니다.

좀 더 자세히 풀어보자면 아래와 같습니다.

1. SYN 단계 : 클라이언트는 서버에 클라이언트의 ISN을 담아 SYN을 보냅니다. ISN은 새로운 TCP 연결의 첫 번째 패킷에 할당된 임의의 시퀀스 번호를 말하며, 이는 장치마다 다를 수 있습니다.
2. SYN + ACK 단계 : 서버는 클라이언트의 SYN을 수신하고 서버의 ISN을 보내며 승인 번호로 클라이언트의 ISN + 1을 보냅니다.
3. ACK 단계 : 클라이언트는 서버의 SYN + ACK을 수신하고 서버의 ISN + 1을 승인 번호로 보냅니다.

이 과정 이후 신뢰성이 확보되고 데이터 전송을 시작합니다. 이 과정이 있으므로 TCP는 신뢰성 있는 계층이라고도 하며, UDP는 이 과정이 존재하지 않아 신뢰성 없는 계층이라고 부릅니다.

또한 해제 시 `4-way handshake` 과정을 통해 연결을 해제합니다.
이 과정은 아래와 같습니다.

1. 클라이언트가 서버에 연결 해제 요청(FIN)을 보냅니다.
2. 서버가 클라이언트에 연결 해제 요청(FIN)에 대한 응답(ACK)을 보냅니다.
3. 클라이언트가 서버에 연결 해제 요청(FIN, ACK)에 대한 응답(ACK)을 보냅니다.

이 과정을 통해 클라이언트와 서버가 연결이 해제됩니다.

이 과정 또한 자세히 풀어보자면 아래와 같습니다.

1. 클라이언트가 연결을 닫으려고 할 때 FIN으로 설정된 세그먼트를 보냅니다. 그리고 클라이언트는 FIN_WAIT_1 상태가 됩니다.
2. 서버는 클라이언트로 ACK라는 승인 세그먼트를 보냅니다. 그리고 CLOSE_WAIT 상태에 들어갑니다. 클라이언트가 세그먼트를 받으면 FIN_WAIT_2 상태가 됩니다.
3. 서버는 ACK를 보내고 일정 시간 이후에 클라이언트에 FIN 이라는 세그먼트를 보냅니다.
4. 클라이언트는 TIME_WAIT 다시 서버로 ACK를 보냅니다. 그 후 서버는 CLOSED 상태가 되며 클라이언트는 일정 시간 이후로 모든 연결이 해제됩니다.

각 용어를 정리하자면 아래와 같습니다.

1. SYN : SYNchronization의 약자이며 연결 요청 플래그를 말합니다.
2. ACK : Acknowledgment의 약자이며 승인 플래그를 말합니다.
3. FIN : Finis 의 약자이며 연결 해제 플래그를 말합니다.
4. ISN : Initial Sequence Number의 약자이며 초기 시퀀스 번호를 말합니다.

### 2.3 인터넷 계층

인터넷 계층은 데이터를 네트워크 계층으로 전달하는 역할을 합니다.
즉, 장치로부터 받은 네트워크 패킷을 IP 주소로 지정된 목적지로 전송하기 위해 사용되는 계층입니다.
IP , ARP, ICMP 프로토콜이 이 계층에서 사용됩니다.
상대방이 제대로 받았는지에 대해 보장하지 않는 비연결형적인 특징을 가지고 있습니다.

### 2.4 링크 계층

링크 계층은 전선, 광섬유, 무선 등으로 실질적으로 데이터를 전달하며 장치 간에 신호를 주고 받는 규칙을 정하는 계층입니다.
네트워크 접근 계층이라고도 합니다.

## 3. 네트워크 주소란?

TCP/IP 4계층 구조를 이해했다면, 이제 데이터가 실제로 어디로 전달되는지를 결정하는 요소를 살펴볼 차례입니다.
네트워크에서 모든 장치는 하나의 ‘주소’를 가지고 있으며, 이 주소를 기반으로 패킷이 목적지까지 도달하게 됩니다.

네트워크 주소는 말 그대로 네트워크 상의 장치를 구분하기 위한 식별자이며, 논리적 주소(IP 주소)와 물리적 주소(MAC 주소)로 구분할 수 있습니다.
이제 이 주소들이 어떤 역할을 하며 어떻게 사용되는지 하나씩 살펴보겠습니다.

## 4. IP 주소란?

컴퓨터와 컴퓨터 간의 통신을 할 때 가장 중요한 요소가 바로 IP 주소입니다.
정확히는 IP 주소에서 ARP를 통해 MAC 주소를 조회하여 통신을 합니다.

ARP(Address Resolution Protocol)는 IP 주소로 부터 MAC 주소를 구하는 IP와 MAC 주소의 다리 역할을 하는 프로토콜입니다.
이를 통해 가상 주소인 IP 주소를 물리적 주소인 MAC 주소로 변환합니다.

반대로 RARP(Reverse Address Resolution Protocol)로 MAC 주소를 가상 주소인 IP 주소로 변환하기도 합니다.

## 4.1 IP 주소로 통신하는 과정 — 홉바이홉(Hop-by-Hop) 통신

IP 기반 통신은 한 번에 최종 목적지로 바로 도달하지 않고,  
중간 라우터들을 하나씩 거쳐 이동하는 방식을 사용합니다.  
이를 **홉바이홉 통신**이라고 합니다.

각 패킷은 다음과 같은 과정을 거칩니다.

1. 목적지 IP를 기준으로 라우터의 라우팅 테이블을 조회
2. 다음 라우터(Next Hop)를 결정
3. 다음 라우터로 패킷 전달
4. 반복하며 최종 목적지까지 도달

이 과정에서 핵심 역할을 하는 것이 바로 **라우팅(routing)** 입니다.

또한 라우팅 테이블에는 다음 정보들이 포함됩니다.

- 목적지 네트워크 주소
- 서브넷 마스크
- 다음 홉(Next Hop)
- 사용할 인터페이스
- 경로 우선순위(metric)

라우터는 이 정보를 기반으로  
**“이 패킷을 어디로 보낼지”** 결정합니다.

### 4.1 IP 주소 체계

IP 주소는 IPv4와 IPv6로 나뉩니다.
IPv6으로 가는 단계이지만 아직은 IPv4가 대부분 사용되고 있습니다.

- IPv4 : 32비트를 8비트 단위로 점을 찍어 표기하며, 123.45.67.89 와 같은 형태로 표현합니다.
- IPv6 : 64비트를 16비트 단위로 점을 찍어 표기하며, 2001:db8::ff00:42:8329와 같은 형태로 표현합니다.

IPv4는 클래스 기반 할당 방식을 차용하였으며, 주소 고갈 문제로 CIDR 방식을 사용하고 있습니다.
IPv4에서는 클래스 A, B, C, D, E 5가지 클래스로 나뉩니다.
앞에서부터 네트워크 주소, 호스트 주소, 서브넷 마스크 등의 정보가 들어가 있습니다.

클래스 A,B,C는 일대일 통신 , 클래스 D는 멀티캐스트 통신, E는 예비용으로 사용됩니다.

- 클래스 A : 0.0.0.0 ~ 127.255.255.255
- 클래스 B : 128.0.0.0 ~ 191.255.255.255
- 클래스 C : 192.0.0.0 ~ 223.255.255.255
- 클래스 D : 224.0.0.0 ~ 239.255.255.255
- 클래스 E : 240.0.0.0 ~ 255.255.255.255

또한 구분 비트로도 상세하게 나눌 수 있습니다.

- 클래스 A : 구분 비트 0
- 클래스 B : 구분 비트 10
- 클래스 C : 구분 비트 110

### 4.2 공인 IP 주소와 사설 IP 주소

IP 주소는 사용하는 목적에 따라 크게 두 종류로 나뉩니다.

### 4.2.1 공인 IP 주소

- 인터넷에서 유일한 주소
- ISP가 할당
- 외부 인터넷과 직접 통신 가능

### 4.2.2 사설 IP 주소

- 로컬 네트워크에서만 사용
- NAT를 통해 공인 IP로 변환하여 인터넷 접속

### 4.2.3 NAT

NAT(Network Address Translation)는 사설 IP 주소를 공인 IP 주소로 변환하여 인터넷 접속을 가능하게 하는 기술입니다.
엄밀히 말하면 패킷이 라우팅 장치를 통해 전송되는 동안 패킷의 IP 주소 정보를 수정하여 IP 주소를 다른 주소로 매핑하는 방법입니다.

### 4.2.4 서브넷 마스크

서브넷 마스크는 IP 주소에서 어느 부분이 네트워크(Network) 영역인지, 어느 부분이 호스트(Host) 영역인지 구분하는 값입니다.
즉, 하나의 IP 주소를 네트워크 주소 + 호스트 주소로 나누기 위한 마스크(mask) 역할을 합니다.

예를 들어 `192.168.10.15` 라는 주소가 있을 때 이게 `192.168.10.0`에 해당하는지 혹은 더 큰 네트워크인지 알 수가 없습니다. 이를 위해 필요한게 서브넷 마스크 개념입니다.

기본적으로 서브넷 마스크도 32비트로 이루어진 값입니다.

예를 들어 아래와 같다고 가정할 때
1로 채워진 부분은 **네트워크 영역**이고 0으로 채워진 부분은 **호스트 영역** 이라고 할 수 있습니다.

```bash
255.255.255.0
11111111.11111111.11111111.00000000 (2진수)
```

그래서 아래와 같이 호스트 수를 계산할 수도 있습니다.
**호스트 수 = 2^(호스트 비트 수) - 2**

예를 들어 `255.255.255.0` 은 2진수로 나타내면 위와 같이 0이 8개이므로 8비트가 호스트 영역이라 할 수 있고 호스트 수는 2^8 - 2 = 254개 입니다.

또한 서브넷 마스크로 네트워크 주소 계산 또한 가능합니다.

예를 들어 `192.168.10.15` 라는 주소가 있을 때 서브넷 마스크가 `255.255.255.0` 이라면 네트워크 주소는 `192.168.10.0` 이라고 할 수 있습니다.

이를 계산하는 방법은 아래와 같습니다.
**네트워크 주소 = IP 주소 & 서브넷 마스크**

아래 예시를 보면 더 쉽게 이해가 가능합니다.

```bash
192.168.10.15
255.255.255.0
----------------
192.168.10.0   → 네트워크 주소
```

이처럼 서브넷 마스크는 네트워크 주소 계산 및 구체적인 네트워크 영역을 구분하는데 있어 중요한 개념입니다.

## 5. 네트워크 관련 기기 종류에 대해

네트워크를 구성하는 기기들은 앞서 살펴본 TCP/IP 4계층 모델의 어느 계층에서 동작하는지에 따라 역할과 특징이 달라집니다.
각 계층별로 동작하는 주요 네트워크 기기들을 살펴보겠습니다.

### 5.1 애플리케이션 계층 기기

애플리케이션 계층에서 동작하는 기기로는 L7 스위치가 있습니다.

**L7 스위치**는 로드밸런서라고도 불리며, 서버의 부하를 분산시키는 기기입니다.
URL, 쿠키, 페이로드 등 애플리케이션 계층의 정보를 기반으로 트래픽을 분산시킬 수 있습니다.

주요 로드밸런싱 알고리즘으로는 다음과 같은 것들이 있습니다:

- **라운드로빈 방식**: 요청을 순서대로 각 서버에 균등하게 분배합니다.
- **가중 라운드로빈 방식**: 각 서버에 가중치를 부여하여 처리 능력에 따라 요청을 분배합니다.
- **최소 연결 방식**: 현재 연결 수가 가장 적은 서버로 요청을 보냅니다.
- **IP 해시 방식**: 클라이언트의 IP 주소를 해싱하여 특정 서버로 매핑합니다.

### 5.2 인터넷 계층 기기

인터넷 계층에서 동작하는 대표적인 기기는 라우터입니다.

**라우터**는 여러 개의 네트워크를 연결하고, 패킷을 최적의 경로로 전달하는 장치입니다.
라우팅 테이블을 참조하여 목적지 IP 주소를 확인하고 다음 홉(hop)으로 패킷을 전송합니다.

라우터는 다음과 같은 특징을 가집니다:

- 서로 다른 네트워크 대역을 연결할 수 있습니다.
- NAT 기능을 통해 사설 IP를 공인 IP로 변환합니다.
- 라우팅 프로토콜(RIP, OSPF, BGP 등)을 사용하여 최적 경로를 결정합니다.

**L3 스위치**는 라우터와 유사한 기능을 하지만, 하드웨어 기반으로 더 빠른 속도로 처리할 수 있습니다.

### 5.3 데이터 링크 계층 기기

데이터 링크 계층에서 동작하는 기기로는 스위치와 브리지가 있습니다.

**스위치**는 MAC 주소를 기반으로 패킷을 전달하는 장치입니다.
MAC 주소 테이블을 통해 어떤 포트에 어떤 장치가 연결되어 있는지 학습하고, 해당 포트로만 데이터를 전송합니다.

스위치의 주요 특징:

- **유니캐스트 전송**: 목적지 MAC 주소를 학습하여 해당 포트로만 전송합니다.
- **전이중 통신**: 송신과 수신을 동시에 할 수 있어 충돌이 발생하지 않습니다.
- **VLAN 지원**: 하나의 물리적 스위치를 여러 개의 논리적 네트워크로 분리할 수 있습니다.

**브리지**는 두 개의 근거리 통신망(LAN)을 연결하는 장치입니다.
스위치와 유사하지만 포트 수가 적고 소프트웨어 기반으로 동작합니다.

### 5.4 물리 계층 기기

물리 계층에서 동작하는 기기로는 허브, 리피터, AP 등이 있습니다.

**허브**는 여러 대의 컴퓨터를 연결하는 장치입니다.
하지만 허브는 받은 신호를 모든 포트로 브로드캐스트하기 때문에 충돌이 자주 발생하며, 보안에도 취약합니다.
현재는 거의 사용되지 않고 스위치로 대체되었습니다.

**리피터**는 신호를 증폭시키는 장치입니다.
네트워크 케이블의 거리가 길어지면 신호가 약해지는데, 리피터를 사용하여 신호를 재생성하고 증폭시킵니다.

**AP(Access Point, 공유기)**는 유선 LAN과 무선 LAN을 연결하는 장치입니다.
무선 신호를 송수신하여 여러 무선 장치가 네트워크에 접속할 수 있도록 합니다.

### 5.5 기기 선택 시 고려사항

네트워크 기기를 선택할 때는 다음과 같은 사항을 고려해야 합니다:

- **처리 속도**: 네트워크 트래픽 양에 따라 적절한 처리 성능을 가진 기기를 선택합니다.
- **확장성**: 향후 네트워크 확장을 고려하여 포트 수와 업그레이드 가능성을 확인합니다.
- **보안 기능**: 방화벽, ACL(Access Control List) 등의 보안 기능 지원 여부를 확인합니다.
- **관리 편의성**: 웹 기반 관리, CLI, SNMP 등 관리 인터페이스를 고려합니다.

## 6. HTTP 프로토콜에 대해

마지막으로 HTTP는 전송 계층 위에 있는 애플리케이션 계층으로서 웹 서비스 통신에 사용됩니다.
HTTP/1.0부터 현재 HTTP/3까지 왔는데 차례대로 살펴보겠습니다.

### 6.1 HTTP/1.0

HTTP/1.0은 한 연결 당 하나의 요청을 처리하도록 설계 되었습니다.
이는 RTT의 증가, 즉 패킷이 목적지에 도달하고 나서 다시 출발지로 돌아오기까지 걸리는 패킷 왕복 시간의 증가를 불러왔습니다.
서버로부터 파일을 불러올 때마다 계속 TCP의 3-way handshake 과정을 열어야 하기 때문입니다.

이를 해결하기 위해 이미지 스플리팅, 코드 압축, 이미지 Base 64 인코딩을 사용하곤 했습니다.

#### 이미지 스플리팅

많은 이미지를 다운로드 받게 되면 과부하가 걸리기 때문에 많은 이미지가 합쳐 있는 하나의 이미지를 다운로드 받고, 이를 기반으로 이미지를 표기하는 방법입니다.
하나의 이미지를 받고 background-position을 사용하여 두 이미지를 설정하도록 하는 방법입니다.

```css
.container {
  background-image: url('image.png');
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
}

.container div {
  background-position: 2px 2px;
}

.container div:nth-child(1) {
  background-position: 2px 4px;
}
```

#### 코드 압축

코드 압축은 코드를 압축해서 개행 문자, 빈칸 등을 없애서 코드의 크기를 최소화 하는 방법입니다.

#### 이미지 Base 64 인코딩

이미지 파일을 64진법으로 이루어진 문자열로 인코딩하는 방법입니다. 이 방법을 사용하면 서버와의 연결을 열고 이미지에 대해 서버에 HTTP 요청을 할 필요가 없다는 장점이 있습니다만, 크기가 더 커진다는 단점 또한 존재해서 주의해야 합니다.

### 6.2 HTTP/1.1

HTTP/1.1은 매번 TCP 연결을 하는 것이 아닌 한 번 TCP 초기화를 한 이후에 `keep-alive` 옵션을 사용하여 여러 개의 파일을 송수신할 수 있게 바뀌었습니다.

### 6.3 HTTP/2

HTTP/2는 SPDY 프로토콜에서 파생된 앞서 나온 방식보다 더 지연 시간을 줄이고 응답 시간을 빠르게 하며, 멀티플렉싱, 헤더압축, 서버 푸시 등의 우선순위 처리를 지원하는 프로토콜입니다.

`멀티플렉싱` 이란 여러 개의 스트림을 사용하여 송수신한다는 것입니다.

이를 통해 특정 스트림의 패킷이 손실되었다고 하더라도 해당 스트림에만 영향을 미치고 나머지 스트림은 동작합니다.

`스트림`이란 시간이 지남에 따라 사용할 수 있게 되는 일련의 데이터 요소를 가리키는 데이터 흐름을 뜻합니다.

### 6.4 HTTPS

HTTP/2.0은 HTTPS 위에서 동작하는데 애플리케이션 계층과 전송 계층 사이에 신뢰 계층인 SSL/TSL 계층을 넣은 신뢰할 수 있는 HTTP 요청을 말합니다.
이를 통해 통신을 암호화 할 수 있습니다.

`SSL/TSL`은 전송 계층에서 보안을 제공하는 프로토콜입니다. 클라이언트와 서버가 통신할 때 SSL/TSL 계층을 통해 제 3자가 도청하거나 변조하지 못하도록 합니다.

### 6.5 HTTP/3

TCP 위에서 돌아가는 HTTP/2와 달리 QUIC이라는 계층 위에서 돌아가며, UDP 위에서 동작하는 프로토콜입니다.
